import { Component, Input, Output, NgZone, EventEmitter, ViewChild, Inject, ChangeDetectionStrategy, } from '@angular/core';
import { RoundProgressService } from './round-progress.service';
import { ROUND_PROGRESS_DEFAULTS } from './round-progress.config';
import { RoundProgressEase } from './round-progress.ease';
export class RoundProgressComponent {
    constructor(service, easing, defaults, ngZone) {
        this.service = service;
        this.easing = easing;
        this.defaults = defaults;
        this.ngZone = ngZone;
        /** Radius of the circle. */
        this.radius = this.defaults.radius;
        /** Name of the easing function to use when animating. */
        this.animation = this.defaults.animation;
        /** Time in millisconds by which to delay the animation. */
        this.animationDelay = this.defaults.animationDelay;
        /** Duration of the animation. */
        this.duration = this.defaults.duration;
        /** Width of the circle's stroke. */
        this.stroke = this.defaults.stroke;
        /** Color of the circle. */
        this.color = this.defaults.color;
        /** Background color of the circle. */
        this.background = this.defaults.background;
        /** Whether the circle should take up the width of its parent. */
        this.responsive = this.defaults.responsive;
        /** Whether the circle is filling up clockwise. */
        this.clockwise = this.defaults.clockwise;
        /** Whether to render a semicircle. */
        this.semicircle = this.defaults.semicircle;
        /** Whether the tip of the progress should be rounded off. */
        this.rounded = this.defaults.rounded;
        /** Emits when a new value has been rendered. */
        this.onRender = new EventEmitter();
        this.lastAnimationId = 0;
    }
    /** Animates a change in the current value. */
    _animateChange(from, to) {
        if (typeof from !== 'number') {
            from = 0;
        }
        to = this._clamp(to);
        from = this._clamp(from);
        const self = this;
        const changeInValue = to - from;
        const duration = self.duration;
        // Avoid firing change detection for each of the animation frames.
        self.ngZone.runOutsideAngular(() => {
            const start = () => {
                const startTime = self.service.getTimestamp();
                const id = ++self.lastAnimationId;
                requestAnimationFrame(function animation() {
                    const currentTime = Math.min(self.service.getTimestamp() - startTime, duration);
                    const value = self.easing[self.animation](currentTime, from, changeInValue, duration);
                    self._setPath(value);
                    self.onRender.emit(value);
                    if (id === self.lastAnimationId && currentTime < duration) {
                        requestAnimationFrame(animation);
                    }
                });
            };
            if (this.animationDelay > 0) {
                setTimeout(start, this.animationDelay);
            }
            else {
                start();
            }
        });
    }
    /** Sets the path dimensions. */
    _setPath(value) {
        if (this.path) {
            const arc = this.service.getArc(value, this.max, this.radius - this.stroke / 2, this.radius, this.semicircle);
            this.path.nativeElement.setAttribute('d', arc);
        }
    }
    /** Clamps a value between the maximum and 0. */
    _clamp(value) {
        return Math.max(0, Math.min(value || 0, this.max));
    }
    /** Determines the SVG transforms for the <path> node. */
    getPathTransform() {
        const diameter = this._getDiameter();
        if (this.semicircle) {
            return this.clockwise
                ? `translate(0, ${diameter}) rotate(-90)`
                : `translate(${diameter + ',' + diameter}) rotate(90) scale(-1, 1)`;
        }
        else if (!this.clockwise) {
            return `scale(-1, 1) translate(-${diameter} 0)`;
        }
    }
    /** Resolves a color through the service. */
    resolveColor(color) {
        return this.service.resolveColor(color);
    }
    /** Change detection callback. */
    ngOnChanges(changes) {
        if (changes.current) {
            this._animateChange(changes.current.previousValue, changes.current.currentValue);
        }
        else {
            this._setPath(this.current);
        }
    }
    /** Diameter of the circle. */
    _getDiameter() {
        return this.radius * 2;
    }
    /** The CSS height of the wrapper element. */
    _getElementHeight() {
        if (!this.responsive) {
            return (this.semicircle ? this.radius : this._getDiameter()) + 'px';
        }
    }
    /** Viewbox for the SVG element. */
    _getViewBox() {
        const diameter = this._getDiameter();
        return `0 0 ${diameter} ${this.semicircle ? this.radius : diameter}`;
    }
    /** Bottom padding for the wrapper element. */
    _getPaddingBottom() {
        if (this.responsive) {
            return this.semicircle ? '50%' : '100%';
        }
    }
}
RoundProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'round-progress',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "<svg xmlns=\"http://www.w3.org/2000/svg\" [attr.viewBox]=\"_getViewBox()\">\n  <circle\n    fill=\"none\"\n    [attr.cx]=\"radius\"\n    [attr.cy]=\"radius\"\n    [attr.r]=\"radius - stroke / 2\"\n    [style.stroke]=\"resolveColor(background)\"\n    [style.stroke-width]=\"stroke\"/>\n\n  <path\n    #path\n    fill=\"none\"\n    [style.stroke-width]=\"stroke\"\n    [style.stroke]=\"resolveColor(color)\"\n    [style.stroke-linecap]=\"rounded ? 'round' : ''\"\n    [attr.transform]=\"getPathTransform()\"/>\n</svg>\n",
                host: {
                    role: 'progressbar',
                    '[attr.aria-valuemin]': 'current',
                    '[attr.aria-valuemax]': 'max',
                    '[style.width]': 'responsive ? "" : _getDiameter() + "px"',
                    '[style.height]': '_getElementHeight()',
                    '[style.padding-bottom]': '_getPaddingBottom()',
                    '[class.responsive]': 'responsive',
                },
                styles: [":host{display:block;overflow:hidden;position:relative}:host(.responsive){padding-bottom:100%;width:100%}:host(.responsive)>svg{height:100%;left:0;position:absolute;top:0;width:100%}"]
            },] }
];
RoundProgressComponent.ctorParameters = () => [
    { type: RoundProgressService },
    { type: RoundProgressEase },
    { type: undefined, decorators: [{ type: Inject, args: [ROUND_PROGRESS_DEFAULTS,] }] },
    { type: NgZone }
];
RoundProgressComponent.propDecorators = {
    path: [{ type: ViewChild, args: ['path',] }],
    current: [{ type: Input }],
    max: [{ type: Input }],
    radius: [{ type: Input }],
    animation: [{ type: Input }],
    animationDelay: [{ type: Input }],
    duration: [{ type: Input }],
    stroke: [{ type: Input }],
    color: [{ type: Input }],
    background: [{ type: Input }],
    responsive: [{ type: Input }],
    clockwise: [{ type: Input }],
    semicircle: [{ type: Input }],
    rounded: [{ type: Input }],
    onRender: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91bmQtcHJvZ3Jlc3MuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9yb3VuZC1wcm9ncmVzcy9yb3VuZC1wcm9ncmVzcy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUVOLE1BQU0sRUFDTixZQUFZLEVBQ1osU0FBUyxFQUNULE1BQU0sRUFHTix1QkFBdUIsR0FDeEIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFDLG9CQUFvQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDOUQsT0FBTyxFQUFDLHVCQUF1QixFQUF3QixNQUFNLHlCQUF5QixDQUFDO0FBQ3ZGLE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBaUJ4RCxNQUFNLE9BQU8sc0JBQXNCO0lBZ0RqQyxZQUNVLE9BQTZCLEVBQzdCLE1BQXlCLEVBQ1EsUUFBK0IsRUFDaEUsTUFBYztRQUhkLFlBQU8sR0FBUCxPQUFPLENBQXNCO1FBQzdCLFdBQU0sR0FBTixNQUFNLENBQW1CO1FBQ1EsYUFBUSxHQUFSLFFBQVEsQ0FBdUI7UUFDaEUsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQTFDeEIsNEJBQTRCO1FBQ25CLFdBQU0sR0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUUvQyx5REFBeUQ7UUFDaEQsY0FBUyxHQUFXLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO1FBRXJELDJEQUEyRDtRQUNsRCxtQkFBYyxHQUFXLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDO1FBRS9ELGlDQUFpQztRQUN4QixhQUFRLEdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUM7UUFFbkQsb0NBQW9DO1FBQzNCLFdBQU0sR0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUUvQywy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b0JBQW9CO1lBRXBCLGlCQUFpQjs0Q0FvRXBCLE1BQU0sU0FBQyx1QkFBdUI7WUEvRWpDLE1BQU07OzttQkE4QkwsU0FBUyxTQUFDLE1BQU07c0JBR2hCLEtBQUs7a0JBR0wsS0FBSztxQkFHTCxLQUFLO3dCQUdMLEtBQUs7NkJBR0wsS0FBSzt1QkFHTCxLQUFLO3FCQUdMLEtBQUs7b0JBR0wsS0FBSzt5QkFHTCxLQUFLO3lCQUdMLEtBQUs7d0JBR0wsS0FBSzt5QkFHTCxLQUFLO3NCQUdMLEtBQUs7dUJBR0wsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgT25DaGFuZ2VzLFxuICBOZ1pvbmUsXG4gIEV2ZW50RW1pdHRlcixcbiAgVmlld0NoaWxkLFxuICBJbmplY3QsXG4gIEVsZW1lbnRSZWYsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtSb3VuZFByb2dyZXNzU2VydmljZX0gZnJvbSAnLi9yb3VuZC1wcm9ncmVzcy5zZXJ2aWNlJztcbmltcG9ydCB7Uk9VTkRfUFJPR1JFU1NfREVGQVVMVFMsIFJvdW5kUHJvZ3Jlc3NEZWZhdWx0c30gZnJvbSAnLi9yb3VuZC1wcm9ncmVzcy5jb25maWcnO1xuaW1wb3J0IHtSb3VuZFByb2dyZXNzRWFzZX0gZnJvbSAnLi9yb3VuZC1wcm9ncmVzcy5lYXNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAncm91bmQtcHJvZ3Jlc3MnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgdGVtcGxhdGVVcmw6ICcuL3JvdW5kLXByb2dyZXNzLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vcm91bmQtcHJvZ3Jlc3MuY29tcG9uZW50LmNzcyddLFxuICBob3N0OiB7XG4gICAgcm9sZTogJ3Byb2dyZXNzYmFyJyxcbiAgICAnW2F0dHIuYXJpYS12YWx1ZW1pbl0nOiAnY3VycmVudCcsXG4gICAgJ1thdHRyLmFyaWEtdmFsdWVtYXhdJzogJ21heCcsXG4gICAgJ1tzdHlsZS53aWR0aF0nOiAncmVzcG9uc2l2ZSA/IFwiXCIgOiBfZ2V0RGlhbWV0ZXIoKSArIFwicHhcIicsXG4gICAgJ1tzdHlsZS5oZWlnaHRdJzogJ19nZXRFbGVtZW50SGVpZ2h0KCknLFxuICAgICdbc3R5bGUucGFkZGluZy1ib3R0b21dJzogJ19nZXRQYWRkaW5nQm90dG9tKCknLFxuICAgICdbY2xhc3MucmVzcG9uc2l2ZV0nOiAncmVzcG9uc2l2ZScsXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgUm91bmRQcm9ncmVzc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgYHBhdGhgIG5vZGUuICovXG4gIEBWaWV3Q2hpbGQoJ3BhdGgnKSBwYXRoOiBFbGVtZW50UmVmO1xuXG4gIC8qKiBDdXJyZW50IHZhbHVlIG9mIHRoZSBwcm9ncmVzcyBiYXIuICovXG4gIEBJbnB1dCgpIGN1cnJlbnQ6IG51bWJlcjtcblxuICAvKiogTWF4aW11bSB2YWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiAqL1xuICBASW5wdXQoKSBtYXg6IG51bWJlcjtcblxuICAvKiogUmFkaXVzIG9mIHRoZSBjaXJjbGUuICovXG4gIEBJbnB1dCgpIHJhZGl1czogbnVtYmVyID0gdGhpcy5kZWZhdWx0cy5yYWRpdXM7XG5cbiAgLyoqIE5hbWUgb2YgdGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hlbiBhbmltYXRpbmcuICovXG4gIEBJbnB1dCgpIGFuaW1hdGlvbjogc3RyaW5nID0gdGhpcy5kZWZhdWx0cy5hbmltYXRpb247XG5cbiAgLyoqIFRpbWUgaW4gbWlsbGlzY29uZHMgYnkgd2hpY2ggdG8gZGVsYXkgdGhlIGFuaW1hdGlvbi4gKi9cbiAgQElucHV0KCkgYW5pbWF0aW9uRGVsYXk6IG51bWJlciA9IHRoaXMuZGVmYXVsdHMuYW5pbWF0aW9uRGVsYXk7XG5cbiAgLyoqIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uICovXG4gIEBJbnB1dCgpIGR1cmF0aW9uOiBudW1iZXIgPSB0aGlzLmRlZmF1bHRzLmR1cmF0aW9uO1xuXG4gIC8qKiBXaWR0aCBvZiB0aGUgY2lyY2xlJ3Mgc3Ryb2tlLiAqL1xuICBASW5wdXQoKSBzdHJva2U6IG51bWJlciA9IHRoaXMuZGVmYXVsdHMuc3Ryb2tlO1xuXG4gIC8qKiBDb2xvciBvZiB0aGUgY2lyY2xlLiAqL1xuICBASW5wdXQoKSBjb2xvcjogc3RyaW5nID0gdGhpcy5kZWZhdWx0cy5jb2xvcjtcblxuICAvKiogQmFja2dyb3VuZCBjb2xvciBvZiB0aGUgY2lyY2xlLiAqL1xuICBASW5wdXQoKSBiYWNrZ3JvdW5kOiBzdHJpbmcgPSB0aGlzLmRlZmF1bHRzLmJhY2tncm91bmQ7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNpcmNsZSBzaG91bGQgdGFrZSB1cCB0aGUgd2lkdGggb2YgaXRzIHBhcmVudC4gKi9cbiAgQElucHV0KCkgcmVzcG9uc2l2ZTogYm9vbGVhbiA9IHRoaXMuZGVmYXVsdHMucmVzcG9uc2l2ZTtcblxuICAvKiogV2hldGhlciB0aGUgY2lyY2xlIGlzIGZpbGxpbmcgdXAgY2xvY2t3aXNlLiAqL1xuICBASW5wdXQoKSBjbG9ja3dpc2U6IGJvb2xlYW4gPSB0aGlzLmRlZmF1bHRzLmNsb2Nrd2lzZTtcblxuICAvKiogV2hldGhlciB0byByZW5kZXIgYSBzZW1pY2lyY2xlLiAqL1xuICBASW5wdXQoKSBzZW1pY2lyY2xlOiBib29sZWFuID0gdGhpcy5kZWZhdWx0cy5zZW1pY2lyY2xlO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSB0aXAgb2YgdGhlIHByb2dyZXNzIHNob3VsZCBiZSByb3VuZGVkIG9mZi4gKi9cbiAgQElucHV0KCkgcm91bmRlZDogYm9vbGVhbiA9IHRoaXMuZGVmYXVsdHMucm91bmRlZDtcblxuICAvKiogRW1pdHMgd2hlbiBhIG5ldyB2YWx1ZSBoYXMgYmVlbiByZW5kZXJlZC4gKi9cbiAgQE91dHB1dCgpIG9uUmVuZGVyOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBwcml2YXRlIGxhc3RBbmltYXRpb25JZCA9IDA7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBzZXJ2aWNlOiBSb3VuZFByb2dyZXNzU2VydmljZSxcbiAgICBwcml2YXRlIGVhc2luZzogUm91bmRQcm9ncmVzc0Vhc2UsXG4gICAgQEluamVjdChST1VORF9QUk9HUkVTU19ERUZBVUxUUykgcHJpdmF0ZSBkZWZhdWx0czogUm91bmRQcm9ncmVzc0RlZmF1bHRzLFxuICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmVcbiAgKSB7fVxuXG4gIC8qKiBBbmltYXRlcyBhIGNoYW5nZSBpbiB0aGUgY3VycmVudCB2YWx1ZS4gKi9cbiAgcHJpdmF0ZSBfYW5pbWF0ZUNoYW5nZShmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInKSB7XG4gICAgICBmcm9tID0gMDtcbiAgICB9XG5cbiAgICB0byA9IHRoaXMuX2NsYW1wKHRvKTtcbiAgICBmcm9tID0gdGhpcy5fY2xhbXAoZnJvbSk7XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VJblZhbHVlID0gdG8gLSBmcm9tO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gc2VsZi5kdXJhdGlvbjtcblxuICAgIC8vIEF2b2lkIGZpcmluZyBjaGFuZ2UgZGV0ZWN0aW9uIGZvciBlYWNoIG9mIHRoZSBhbmltYXRpb24gZnJhbWVzLlxuICAgIHNlbGYubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzZWxmLnNlcnZpY2UuZ2V0VGltZXN0YW1wKCk7XG4gICAgICAgIGNvbnN0IGlkID0gKytzZWxmLmxhc3RBbmltYXRpb25JZDtcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gYW5pbWF0aW9uKCkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gTWF0aC5taW4oc2VsZi5zZXJ2aWNlLmdldFRpbWVzdGFtcCgpIC0gc3RhcnRUaW1lLCBkdXJhdGlvbik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBzZWxmLmVhc2luZ1tzZWxmLmFuaW1hdGlvbl0oY3VycmVudFRpbWUsIGZyb20sIGNoYW5nZUluVmFsdWUsIGR1cmF0aW9uKTtcblxuICAgICAgICAgIHNlbGYuX3NldFBhdGgodmFsdWUpO1xuICAgICAgICAgIHNlbGYub25SZW5kZXIuZW1pdCh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoaWQgPT09IHNlbGYubGFzdEFuaW1hdGlvbklkICYmIGN1cnJlbnRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5hbmltYXRpb25EZWxheSA+IDApIHtcbiAgICAgICAgc2V0VGltZW91dChzdGFydCwgdGhpcy5hbmltYXRpb25EZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqIFNldHMgdGhlIHBhdGggZGltZW5zaW9ucy4gKi9cbiAgcHJpdmF0ZSBfc2V0UGF0aCh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgY29uc3QgYXJjID0gdGhpcy5zZXJ2aWNlLmdldEFyYyh2YWx1ZSwgdGhpcy5tYXgsIHRoaXMucmFkaXVzIC0gdGhpcy5zdHJva2UgLyAyLCB0aGlzLnJhZGl1cywgdGhpcy5zZW1pY2lyY2xlKTtcbiAgICAgIHRoaXMucGF0aC5uYXRpdmVFbGVtZW50LnNldEF0dHJpYnV0ZSgnZCcsIGFyYyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIENsYW1wcyBhIHZhbHVlIGJldHdlZW4gdGhlIG1heGltdW0gYW5kIDAuICovXG4gIHByaXZhdGUgX2NsYW1wKHZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbih2YWx1ZSB8fCAwLCB0aGlzLm1heCkpO1xuICB9XG5cbiAgLyoqIERldGVybWluZXMgdGhlIFNWRyB0cmFuc2Zvcm1zIGZvciB0aGUgPHBhdGg+IG5vZGUuICovXG4gIGdldFBhdGhUcmFuc2Zvcm0oKTogc3RyaW5nIHtcbiAgICBjb25zdCBkaWFtZXRlciA9IHRoaXMuX2dldERpYW1ldGVyKCk7XG5cbiAgICBpZiAodGhpcy5zZW1pY2lyY2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9ja3dpc2VcbiAgICAgICAgPyBgdHJhbnNsYXRlKDAsICR7ZGlhbWV0ZXJ9KSByb3RhdGUoLTkwKWBcbiAgICAgICAgOiBgdHJhbnNsYXRlKCR7ZGlhbWV0ZXIgKyAnLCcgKyBkaWFtZXRlcn0pIHJvdGF0ZSg5MCkgc2NhbGUoLTEsIDEpYDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNsb2Nrd2lzZSkge1xuICAgICAgcmV0dXJuIGBzY2FsZSgtMSwgMSkgdHJhbnNsYXRlKC0ke2RpYW1ldGVyfSAwKWA7XG4gICAgfVxuICB9XG5cbiAgLyoqIFJlc29sdmVzIGEgY29sb3IgdGhyb3VnaCB0aGUgc2VydmljZS4gKi9cbiAgcmVzb2x2ZUNvbG9yKGNvbG9yOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNlcnZpY2UucmVzb2x2ZUNvbG9yKGNvbG9yKTtcbiAgfVxuXG4gIC8qKiBDaGFuZ2UgZGV0ZWN0aW9uIGNhbGxiYWNrLiAqL1xuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMuY3VycmVudCkge1xuICAgICAgdGhpcy5fYW5pbWF0ZUNoYW5nZShjaGFuZ2VzLmN1cnJlbnQucHJldmlvdXNWYWx1ZSwgY2hhbmdlcy5jdXJyZW50LmN1cnJlbnRWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFBhdGgodGhpcy5jdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICAvKiogRGlhbWV0ZXIgb2YgdGhlIGNpcmNsZS4gKi9cbiAgX2dldERpYW1ldGVyKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzICogMjtcbiAgfVxuXG4gIC8qKiBUaGUgQ1NTIGhlaWdodCBvZiB0aGUgd3JhcHBlciBlbGVtZW50LiAqL1xuICBfZ2V0RWxlbWVudEhlaWdodCgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5yZXNwb25zaXZlKSB7XG4gICAgICByZXR1cm4gKHRoaXMuc2VtaWNpcmNsZSA/IHRoaXMucmFkaXVzIDogdGhpcy5fZ2V0RGlhbWV0ZXIoKSkgKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBWaWV3Ym94IGZvciB0aGUgU1ZHIGVsZW1lbnQuICovXG4gIF9nZXRWaWV3Qm94KCk6IHN0cmluZyB7XG4gICAgY29uc3QgZGlhbWV0ZXIgPSB0aGlzLl9nZXREaWFtZXRlcigpO1xuICAgIHJldHVybiBgMCAwICR7ZGlhbWV0ZXJ9ICR7dGhpcy5zZW1pY2lyY2xlID8gdGhpcy5yYWRpdXMgOiBkaWFtZXRlcn1gO1xuICB9XG5cbiAgLyoqIEJvdHRvbSBwYWRkaW5nIGZvciB0aGUgd3JhcHBlciBlbGVtZW50LiAqL1xuICBfZ2V0UGFkZGluZ0JvdHRvbSgpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLnJlc3BvbnNpdmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbWljaXJjbGUgPyAnNTAlJyA6ICcxMDAlJztcbiAgICB9XG4gIH1cbn1cbiJdfQ==